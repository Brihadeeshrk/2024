---
date: 2024/08/03
layout: article
title: August 2024
description: Notes for the month of August, 2024 (ongoing)
tag: microservices, docker
author: You
---

# arch of multi service apps

## what did we learn so far?

- the big challenge in microservices is data
- there are diff ways to share data btw services, we are going with the async approach
- async comm focuses on communicating changes using events to an event bus
- this enables services to be 100% self sufficient
- docker makes it easy to package up services
- kube is a pain to setup but makes it easy to scale and develop services

## painful things from the prev app

- lots of duplicated code - express setup, route handlers etc
- really hard to imagine and picture the logic flow btw services
- diff to remember what properties an event must have
- difficult to test event flows
- machine gets laggy running kube, docker etc
- what if you were crazy and did some crazy operations simultaneously, that would (potentially) break our model

## proposed changes

| old prj                                                                                                       | new proj                                                                 |
| ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| a lot of duplicated code                                                                                      | build a cenral lib as an npm module to share btw our diff projects       |
| really hard to imagine and picture the logic flow btw services                                                | precisely define all the events in this shared package                   |
| diff to remember what properties an event must have                                                           | use ts                                                                   |
| difficult to test event flows                                                                                 | write tests for as much as possible                                      |
| machine gets laggy running kube, docker etc                                                                   | run a kube cluster in the cloud and dev on it almost as quickly as local |
| what if you were crazy and did some crazy operations simultaneously, that would (potentially) break our model | introduce a lot of code to handle concurrency between services           |

## what are we going to build?

- a ticketing app like bms
- features
  - users can list tickets for sale, instead of the business
  - other users can purchase the ticket
  - any user can do both operations
  - when a user attempts to buy a ticket, the ticket is "locked" for 15mins. the user has 15mins to enter their payment info
  - while locked no other user can purchase that ticket. after 15mins, the ticket will unlock
  - ticket prices can be edited if they are unlocked

## tables/ resources

- user collection
  - email
  - password
- ticket
  - title
  - price
  - userId (ref to user)
  - orderId (ref to order)
- order
  - userId (ref to user)
  - status - created, cancelled, awaiting payment, completed
  - ticketId
  - createdAt
- charge
  - orderId (ref to order)
  - status - created, failed, completed
  - amount
  - stripeId
  - stripeRefundId

## diff services

- auth - handles everything related to user signup, signin, logout
- tickets - ticket creation/ editing. this service knows whether a ticket can be edited or not
- orders - order creation/ editing
- expiration - watches for orders to be created, cancels them after 15mins
- payments - handles credit card payments. cancels orders if payments fail, completes if payment succeed

## understanding resource -> service relation

- if you notice, except for expiration, we have a service for every resource
- is this the best approach? probably not
- its project specific and you have to think about it properly

## events and arch design

- events
  - UserCreated
  - UserUpdated
  - OrderCreated
  - OrderCancelled
  - OrderExpired
  - TicketCreated
  - TicketUpdated
  - ChargeCreated
- architecture
  - front end - next js
  - we're going to have all the services interact with mongodb
  - expiration is the only service that uses redis
  - all of the services are going to talk to a NATS streaming server which is a prod grade event bus

## project setup

- the project has been setup in a diff gh repo,Â [ticket-booking-microservices-app](https://github.com/Brihadeeshrk/ticket-booking-microservices-app)
- and a point i didnt mention before that i'm mentioning now, in dev when we need to spoof the ingress server by going to domains etc
- (if the above point didnt make sense, in the above project we basically gave the url of posts.com, such that if the user goes to posts.com/endpoints he would be able to interact with our servers and services)
- in order to do this, on mac we edit the `/etc/hosts` file by `vi /etc/hosts` or `code /etc/hosts`
- and then we add a new record `127.0.0.1 posts.com`
- and if we save, we get an error that says, retry with sudo (or something)
- we enter the password and that's it, if we visit posts.com in the browser, we're indirectly hitting the localhost where our ingress server is running

## auth service

- an image was created and using skaffold, the containers, services and everything were created
- one thing i observed is that, if i used ImplementationSpecific under pathType in the ingress-srv.yaml file, the server would work properly
- but when i used Prefix, it all worked fine
- so, just a note (not sure why, it isnt working. i havent done the research)

---
date: 2024/05/06
layout: article
title: May 2024
description: Notes for the month of May, 2024 (ongoing)
tag: react testing library, jest
author: You
---

so this month, taking the advice of one of the smartest people [i know](https://anu18.com/), I'll be taking up or rather, ill be trying to get in-depth understanding of React and its testing library.

so, for this, we're going to come across a vite app shows 6 random products as soon as the app loads, now every product has a thumbnail, a category, a title, a price and a "add to cart" button
if the user scrolls down, theres a "Load More Products" button that gives the user 6 more products.

so what sort of tests can we write for this project?
for this lets understand the processes that occur
app loads -> 6 products are shown -> press load more button -> 6 more products are shown

so if you think about it, we can write 2 tests in this scenario
one test to check if 6 products are shown as soon as the app launches
and one more test to check if 6 more products are shown when we click on the button

so in our project we create a file called `App.test.js`

```js
import { render, screen, waitFor } from "@testing-library/react";
import user from "@testing-library/user-event";
import App from "./App";

test("shows 6 products by default", async () => {
  // going to write a fn thats going to render our Apo component
  render(<App />);
  const titles = await screen.findAllByRole("heading");
  expect(titles).toHaveLength(6);
});

test("Clicking on the button shows 6 more products", async () => {
  render(<App />);
  const button = await screen.findByRole("button", {
    name: /load more/i,
  });
  user.click(button);
  await waitFor(async () => {
    const titles = await screen.findAllByRole("heading");
    expect(titles).toHaveLength(12);
  });
});
```

lets start off with a list of packages that we'll end up using when we talk about testing a react application.

1. `@testing-library/react` - takes our component and renders it, and gets it ready for testing.
2. `@testing-library/user-event` - helps simulate user input like typing and clicking. for this, BTS we're using another lib called `@testing-library/dom`. now, this package is already included in our proj with `@testing-library/react` and this `/dom` package helps us find eles that are rendered by our components
3. `jest` - runs our tests, reports results
4. `jsdom` - simulates a browser when running in a node env

now, when we just ran `yarn test` how is it that all the tests were run automatically?

> so `jest` finds all files in the src folder that end with `.spec.js`, or `.test.js` or are placed in a folder called `__test__`

## test writing process for the first project

1. pick out one component to test in isolation
2. make a test file for the component
3. decide what the imp parts of the component are
4. write a test to make sure all the parts of the components work as expected
5. run test at cmdline

### WRT UserForm component

what are the most imp parts of this component?

1. show 2 inputs and 1 button
2. enter a name + email and then submitting the form calls the onUserAdd callback to be called

```jsx
import { render, screen } from "@testing-library/react";
import user from "@testing-library/user-event";
import UserForm from "./UserForm";

test("check for 2 inputs and a button", () => {
  // render the component
  render(<UserForm />);
  // check if the inputs and the button are being rendered
  const inputs = screen.getAllByRole("textbox");
  const button = screen.getByRole("button");
  // assertion: to make sure that the component is behaving as expected
  expect(inputs).toHaveLength(2);
  expect(button).toBeInTheDocument();
});
```

## queries

- a super imp part of testing is finding the ele that our component has created.
- query fns are how we are going to find eles that our component has rendered
- tedious to find eles
- there are about 48 fns that are used to find eles
- these fns are provided by the RTL Query System
- some ones that are most probably used (no need to memorise)
  - screen.getByRole()
  - screen.findAllByDisplayValue()
  - screen.queryAllByRole()
  - screen.queryByRole()
  - screen.findByRole()
  - screen.queryByLabelText()
  - screen.findAllByTitle()
  - screen.findByTitle()
  - screen.getByLabelText()

### understanding the queries we wrote earlier in the UserForm test

```jsx
const inputs = screen.getAllByRole("textbox");
const button = screen.getByRole("button");
```

- the role is referring to something known as an `ARIA role`
- Aria roles clarify the purpose of a HTML ele
- mostly used by screenreaders
- many html eles have an 'implicit', or automatically assigned role
- eles can be assigned a role manually also and even trained engineers do this incorrectly at times (not advised to do)

now, some roles are:

- 'heading' -> h1 h2 h3 h4 h5 h6
- 'list' -> ul li
- 'button' -> button
- 'link' -> a
- 'textbox' -> input, type="text"
- ... and much more

finding eles by this 'role' method is the preferred way of testing, and RTL pushes us to use this method

## assertions

basically telling the test file the expected behaviour
so to test this assertion we use the `expect` keyword which is a global keyword

and this expect always takes in a value and to this value we attach a fn called as a matcher, ie something like `.toHaveLength(2)` etc
there are MANY matchers, some provided by jest, some provided by RTL

now, WRT the UserForm component, we're getting the onUserAdd prop from the parent App, but when we run this test file as is, notice that we aren't passing a prop
so then technically, onUserAdd is undefined, and this is why the test would fail

so what we can do is, we can pass the onUserAdd prop and give it an empty fn
`<UserForm onUserAdd={() => {}} />`
now there is a small problem, now the goal of this test was to make sure that the test is called with the email and name
so we need to write a function to verify that its being called and also make sure that its being called with the right args
so there is a way to do this _NOTE: THIS IS NOT THE BEST IMPLEMENTATION BUT AN IMPLEMENTATION NEVERTHELESS_
we can have an array called argList that stores all the arguments and also a function to store all these args to the array

```jsx
const argList = [];
const callback = (...args) => {
  argList.push(args);
};
```

and we pass this callback to the component

so this is the test so far

```jsx
test("should call onUserAdd when the form is submitted", async () => {
  // NOT THE BEST IMPLEMENTATION
  const argList = [];
  const callback = (...args) => {
    argList.push(args);
  };
  // try to render the component
  render(<UserForm onUserAdd={callback} />);
  // find the 2 inputs
  const [nameInput, emailInput] = screen.getAllByRole("textbox");
  // simulate typing in a name
  await user.click(nameInput);
  await user.keyboard("test name");
  // simulate typing in a email
  await user.click(emailInput);
  await user.keyboard("test@test.com");
  // find the button
  const button = screen.getByRole("button");
  // simulate clicking the button
  await user.click(button);
  // assertion to make sure onUserAdd is called with email and name
  expect(argList).toHaveLength(1);
  expect(argList[0][0]).toEqual({ name: "test name", email: "test@test.com" });
});
```

## mock fns

- its a fake fn that doesnt do anything when its called
- it gets recorded whenever we call it and the args it was called with
- used very often when we need to make sure a component calls a callback fn
- so the mock fn we write is going to store 2 things: how many times it was called, and the args it recvd
- so then we can make assertions to make sure that our mock fn was called once and that were getting the correct data also
- how do we define a mock fn? `const mock = jest.fn()`

and jest has some inbuilt matchers to make sure a mock fn gets called and to make sure it gets the appr. props

```jsx
// makes sure the mock was called
expect(mock).toHaveBeenCalled();
// what args it shouldve received
expect(mock).toHaveBeenCalledWith({
  name: "test name",
  email: "test@test.com",
});
```

another issue we'll have in time, in our UserForm component currently we've typed just 2 input fields name and email in that order, but what if tomo we reearrange it and add more fields? then this line `const [nameInput, emailInput] = screen.getAllByRole("textbox");` would fail the test as it is brittle and hardcoded.
so how do we fix this?
for labels we can provide a htmlFor attr. such that when we tap/click on this label, the input field is active

```html
<label htmlFor="email">enter email</label>
<input type="email" id="email" placeholder="email" />
```

so one way we can target this element can be `screen.getByLabelText(/enter email/i)` or `screen.getByRole('textbox', {name: /enter email/i })`

RTL recommends we use roles, so thats what well be using
the 'i' in the end is basically telling to ignore case sensitivity

so now we have a flexible test, such that if we reorder the components, add more components, this test now, wont fail
and this is the code so far

```jsx
test("should call onUserAdd when the form is submitted", async () => {
  const mock = jest.fn();
  // try to render the component
  render(<UserForm onUserAdd={mock} />);
  // find the 2 inputs
  const nameInput = screen.getByRole("textbox", { name: /name/i });
  const emailInput = screen.getByRole("textbox", { name: /email/i });
  // simulate typing in a name
  await user.click(nameInput);
  await user.keyboard("test name");
  // simulate typing in a email
  await user.click(emailInput);
  await user.keyboard("test@test.com");
  // find the button
  const button = screen.getByRole("button");
  // simulate clicking the button
  await user.click(button);
  // assertion to make sure onUserAdd is called with email and name
  expect(mock).toHaveBeenCalled();
  expect(mock).toHaveBeenCalledWith({
    name: "test name",
    email: "test@test.com",
  });
});
```

### what to do if you dont know which query to use

so RTL provides a fn `screen.logTestingPlaygroundURL()` which is a playground that lets us find the query to help us with the task at hand
and what this'll do is, itll spin up a playground of the component we're trying to test and it'll help us by suggesting possible queries we can use

now at times, we may not be able to select a particular element, which is when we can try styling it, to see if that works
and 9/10 times we'll most probably go for the suggested query

sometimes finding eles by role just doesnt work well
dont obsess over getting the "right" query

here are 2 "escape hatch" ways to find eles when the preferred role approach doesnt work

1. fallback #1 - to find eles using an attr called `data-testid`
   - now if we want to check the # of rows within tbody, we can go to the UserList component, and give the tbody this attr `data-testid="users"`
   - what does this mean? by giving the above prop, we're gaining the ability to target this ele and find whats within it using `{within}` from `@testing-library/react`
     ```jsx
     import { render, screen, within } from "@testing-library/react";
     const rows = within(screen.getByTestId("users")).getAllByRole("row");
     ```

- but this is not advised as we literally have to change the codebase JUST so that we can test it

2.  fallback #2 - container.querySelector()

- so when we call the render fn we're returned multiple things and we can destructure that and take the `{container}` property
- now, if we go back to our playground you'll see that the entire component is wrapped up inside a `<div>` now this div is our container
- and we can perform our normal querySelectors on this container
- but when we run `const table = container.querySelector("table");` we get a red underline in vscode. this is not an error but just a warning asking to avoid this approach and use roles instead
- and we can simply run the following query to check

```jsx
// trying to target tr elements inside tbody
const rows = container.querySelectorAll("tbody tr");
expect(rows).toHaveLength(users.length);
});
```

and this would still have the curly underline as it still recommends us to use roles, but if you want to bypass this, have a comment above the underlined line and type the following `// eslint-disable-next-line`

- so the whole point is, dont spend too much time trying to find roles to use. spend at most 5-6mins to find a role and then test it

### testing the userlist component

we can run the playground tool to find out which role to choose, and if we click on the name, we can see that if we use the role of "cell" we can check if the name and email are being rendered.
but there are so many cells, but we can also optionally pass a 2nd param, a value, like this

```jsx
const row = screen.getByRole("cell", { name: user.name });
```

so in the end we can iterate over the list of users and find out if this user is being rendered or not simply by using the `.toBeInTheDocument()` query
final test:

```jsx
test("render the email and name of every user", () => {
  const users = [
    { name: "Sam", email: "test1@test.com" },
    { name: "Jane 2", email: "test2@test.com" },
  ];
  render(<UserList users={users} />);

  for (const user of users) {
    const name = screen.getByRole("cell", { name: user.name });
    const email = screen.getByRole("cell", { name: user.email });
    expect(name).toBeInTheDocument();
    expect(email).toBeInTheDocument();
  }
});
```

one issue i ran into was that, initially both the dummy users had the same email, so when that happened, the test failed

### beforeEach()

so when we have multiple tests in a file, lets just say before a particular you want some setup done. thats where the beforeEach() fn comes into play

so whenever jest comes across a beforeEach block, its going to run it before EVERY TEST
however it IS STRICTLY ADVISED THAT WE DO NOT render components here. its not an error, but a WARNING by rtl

```jsx
beforeEach(() => {
  // some setup
});
```

### testing the App

```jsx
import { render, screen } from "@testing-library/react";
import user from "@testing-library/user-event";
import App from "./App";

test("can receive a new user and show it on the screen", async () => {
  render(<App />);

  const nameInput = screen.getByRole("textbox", { name: /name/i });
  const emailInput = screen.getByRole("textbox", { name: /email/i });

  await user.click(nameInput);
  await user.keyboard("brihadeesh");

  await user.click(emailInput);
  await user.keyboard("brihadeesh@test.com");

  const button = screen.getByRole("button", { name: /add user/i });
  await user.click(button);

  const name = screen.getByRole("cell", { name: "brihadeesh" });
  const email = screen.getByRole("cell", { name: "brihadeesh@test.com" });

  expect(name).toBeInTheDocument();
  expect(email).toBeInTheDocument();
});
```

### to use the rtl cli book

to use the rtl cli book run `npx rtl-book server filename.js` now this filename can be any file name, basically all notes you type up will be saved here
and to re run this test book, you can just re run the same cmd again

### when to use which query?

there are like 3 types of queries and they start with:

- getBy / getAllBy
- findBy / findAllBy
- queryBy / queryAllBy

- to find a single element we use getBy, findBy, queryBy
- to find multiple elements we use getAllBy, findAllBy, queryAllBy

when to use each?

- to prove an ele exists? getBy / getAllBy
- to prove an ele DOESNT exist? queryBy / queryAllBy
- to make sure an ele EVENTUALLY exists - findBy / findAllBy

if we use getBy and we find ele that is 0 or more than 1, we get an error and our test FAILS

now how do you write an expect block to test for failure?

```
expect(() => screen.getByRole("textbox")).toThrow()
```

findBy - operates async and it watches the op of our component over a span of 1s by default and every 50ms or so its going to try and find an ele, if it doesnt find it by the end of that 1s, its going to throw an error

here are some snippets of tests of how getBy queryBy and findBy react to finding

- 0 eles
- 1 ele
- more than 1 ele

### 0 eles

```js
test("how getBy, findBy and queryBy react to finding 0 elements", async () => {
  render(<ColorList />);

  // getBy
  expect(() => screen.getByRole("textbox")).toThrow();

  // queryBy
  expect(screen.queryByRole("textbox")).toEqual(null);

  // findBy
  let errorThrown = false;
  try {
    await screen.findByRole("textbox");
  } catch (error) {
    errorThrown = true;
  }
  expect(errorThrown).toEqual(true);
});
```

- now since the color list component doesnt have a textbox, we've to pass a callback fn to getByRole. otherwise itll throw an error
- and queryBy returns null if the ele doesnt exist, so thats why we have a toEqual(null) there
- and since findBy waits for a second to run, we put it in a catch block and catch the error to prevent the test from failing

### 1 ele

```js
test("how getBy, findBy and queryBy react to finding 0 elements", async () => {
  render(<ColorList />);

  expect(screen.getByRole("list")).toBeInTheDocument();

  expect(screen.queryByRole("list")).toBeInTheDocument();

  expect(await screen.findByRole("list")).toBeInTheDocument();
});
```

- pretty straightforward test

### more than 1 ele

```js
test("how getBy, findBy and queryBy react to finding 0 elements", async () => {
  render(<ColorList />);

  // getBy
  expect(() => screen.getByRole("listitem")).toThrow();

  // queryBy
  expect(() => screen.queryByRole("listitem")).toThrow();

  // findBy
  let errorThrown = false;
  try {
    await screen.findByRole("listitem");
  } catch (error) {
    errorThrown = true;
  }
  expect(errorThrown).toEqual(true);
});
```

## looking for multiple eles

when looking for multiple eles, we use getAllBy, findAllBy and queryAllBy

```js
test("how getAllBy, findAllBy and queryAllBy ", async () => {
  render(<ColorList />);

  // getBy
  expect(screen.getAllByRole("listitem")).toHaveLength(3);

  // queryBy
  expect(screen.queryAllByRole("listitem")).toHaveLength(3);

  // findBy
  expect(await screen.findAllByRole("listitem")).toHaveLength(3);
});
```

## query fn suffixes

always prefer to use fns that end with byRole. use others if byRole is not an option

- ByRole - finds eles based on their implicit or explicit ARIA role
- ByLabelText - find form eles based on the text their paired labels contain
- ByPlaceholderText - find form eles based upon their placeholder text
- ByText - find eles based on the text they contain
- ByDisplayValue - find eles based on their current value
- ByAltText - find eles based on their alt attr
- ByTitle - find eles based on their title attr
- ByTestId - find eles based on their data-testid attr (not really preferred, but if no option. go for it)

## matchers in jest

note: you cant do a getByRole for a form component, if you want to get it, you must assign an ARIA label to it
matchers are what you chain to the `expect` block

in order to create a custom matcher, you need to first create a function with name of the matcher you wish to have
then this matcher by default gets 2 params, let me explain with an ex
`expect(container).toHaveLength(3)`
with the above example, if we decide to use a custom matcher, we'd get the container AND the value 3 as params
and how do we extend this and tell jest that we have such a matcher?

after we define the custom matcher, we simply do

`expect.extend({name-of-matcher})`

and then, we can use it!

but note that, this function must have a return block with the foll params

```js
return {
  pass: boolean,
  message: () => string, //message to show the user in case the test fails
};
```

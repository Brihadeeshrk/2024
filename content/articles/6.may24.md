---
date: 2024/05/06
layout: article
title: May 2024
description: Notes for the month of May, 2024 (ongoing)
tag: react testing library, jest
author: You
---

so this month, taking the advice of one of the smartest people [i know](https://anu18.com/), I'll be taking up or rather, ill be trying to get in-depth understanding of React and its testing library.

so, for this, we're going to come across a vite app shows 6 random products as soon as the app loads, now every product has a thumbnail, a category, a title, a price and a "add to cart" button
if the user scrolls down, theres a "Load More Products" button that gives the user 6 more products.

so what sort of tests can we write for this project?
for this lets understand the processes that occur
app loads -> 6 products are shown -> press load more button -> 6 more products are shown

so if you think about it, we can write 2 tests in this scenario
one test to check if 6 products are shown as soon as the app launches
and one more test to check if 6 more products are shown when we click on the button

so in our project we create a file called `App.test.js`

```js
import { render, screen, waitFor } from "@testing-library/react";
import user from "@testing-library/user-event";
import App from "./App";

test("shows 6 products by default", async () => {
  // going to write a fn thats going to render our Apo component
  render(<App />);
  const titles = await screen.findAllByRole("heading");
  expect(titles).toHaveLength(6);
});

test("Clicking on the button shows 6 more products", async () => {
  render(<App />);
  const button = await screen.findByRole("button", {
    name: /load more/i,
  });
  user.click(button);
  await waitFor(async () => {
    const titles = await screen.findAllByRole("heading");
    expect(titles).toHaveLength(12);
  });
});
```

lets start off with a list of packages that we'll end up using when we talk about testing a react application.

1. `@testing-library/react` - takes our component and renders it, and gets it ready for testing.
2. `@testing-library/user-event` - helps simulate user input like typing and clicking. for this, BTS we're using another lib called `@testing-library/dom`. now, this package is already included in our proj with `@testing-library/react` and this `/dom` package helps us find eles that are rendered by our components
3. `jest` - runs our tests, reports results
4. `jsdom` - simulates a browser when running in a node env

now, when we just ran `yarn test` how is it that all the tests were run automatically?

> so `jest` finds all files in the src folder that end with `.spec.js`, or `.test.js` or are placed in a folder called `__test__`

## test writing process for the first project

1. pick out one component to test in isolation
2. make a test file for the component
3. decide what the imp parts of the component are
4. write a test to make sure all the parts of the components work as expected
5. run test at cmdline

### WRT UserForm component

what are the most imp parts of this component?

1. show 2 inputs and 1 button
2. enter a name + email and then submitting the form calls the onUserAdd callback to be called

```jsx
import { render, screen } from "@testing-library/react";
import user from "@testing-library/user-event";
import UserForm from "./UserForm";

test("check for 2 inputs and a button", () => {
  // render the component
  render(<UserForm />);
  // check if the inputs and the button are being rendered
  const inputs = screen.getAllByRole("textbox");
  const button = screen.getByRole("button");
  // assertion: to make sure that the component is behaving as expected
  expect(inputs).toHaveLength(2);
  expect(button).toBeInTheDocument();
});
```

## queries

- a super imp part of testing is finding the ele that our component has created.
- query fns are how we are going to find eles that our component has rendered
- tedious to find eles
- there are about 48 fns that are used to find eles
- these fns are provided by the RTL Query System
- some ones that are most probably used (no need to memorise)
  - screen.getByRole()
  - screen.findAllByDisplayValue()
  - screen.queryAllByRole()
  - screen.queryByRole()
  - screen.findByRole()
  - screen.queryByLabelText()
  - screen.findAllByTitle()
  - screen.findByTitle()
  - screen.getByLabelText()

### understanding the queries we wrote earlier in the UserForm test

```jsx
const inputs = screen.getAllByRole("textbox");
const button = screen.getByRole("button");
```

- the role is referring to something known as an `ARIA role`
- Aria roles clarify the purpose of a HTML ele
- mostly used by screenreaders
- many html eles have an 'implicit', or automatically assigned role
- eles can be assigned a role manually also and even trained engineers do this incorrectly at times (not advised to do)

now, some roles are:

- 'heading' -> h1 h2 h3 h4 h5 h6
- 'list' -> ul li
- 'button' -> button
- 'link' -> a
- 'textbox' -> input, type="text"
- ... and much more

finding eles by this 'role' method is the preferred way of testing, and RTL pushes us to use this method

## assertions

basically telling the test file the expected behaviour
so to test this assertion we use the `expect` keyword which is a global keyword

and this expect always takes in a value and to this value we attach a fn called as a matcher, ie something like `.toHaveLength(2)` etc
there are MANY matchers, some provided by jest, some provided by RTL

now, WRT the UserForm component, we're getting the onUserAdd prop from the parent App, but when we run this test file as is, notice that we aren't passing a prop
so then technically, onUserAdd is undefined, and this is why the test would fail

so what we can do is, we can pass the onUserAdd prop and give it an empty fn
`<UserForm onUserAdd={() => {}} />`
now there is a small problem, now the goal of this test was to make sure that the test is called with the email and name
so we need to write a function to verify that its being called and also make sure that its being called with the right args
so there is a way to do this _NOTE: THIS IS NOT THE BEST IMPLEMENTATION BUT AN IMPLEMENTATION NEVERTHELESS_
we can have an array called argList that stores all the arguments and also a function to store all these args to the array

```jsx
const argList = [];
const callback = (...args) => {
  argList.push(args);
};
```

and we pass this callback to the component

so this is the test so far

```jsx
test("should call onUserAdd when the form is submitted", async () => {
  // NOT THE BEST IMPLEMENTATION
  const argList = [];
  const callback = (...args) => {
    argList.push(args);
  };
  // try to render the component
  render(<UserForm onUserAdd={callback} />);
  // find the 2 inputs
  const [nameInput, emailInput] = screen.getAllByRole("textbox");
  // simulate typing in a name
  await user.click(nameInput);
  await user.keyboard("test name");
  // simulate typing in a email
  await user.click(emailInput);
  await user.keyboard("test@test.com");
  // find the button
  const button = screen.getByRole("button");
  // simulate clicking the button
  await user.click(button);
  // assertion to make sure onUserAdd is called with email and name
  expect(argList).toHaveLength(1);
  expect(argList[0][0]).toEqual({ name: "test name", email: "test@test.com" });
});
```

## mock fns

- its a fake fn that doesnt do anything when its called
- it gets recorded whenever we call it and the args it was called with
- used very often when we need to make sure a component calls a callback fn
- so the mock fn we write is going to store 2 things: how many times it was called, and the args it recvd
- so then we can make assertions to make sure that our mock fn was called once and that were getting the correct data also
- how do we define a mock fn? `const mock = jest.fn()`

and jest has some inbuilt matchers to make sure a mock fn gets called and to make sure it gets the appr. props

```jsx
// makes sure the mock was called
expect(mock).toHaveBeenCalled();
// what args it shouldve received
expect(mock).toHaveBeenCalledWith({
  name: "test name",
  email: "test@test.com",
});
```

another issue we'll have in time, in our UserForm component currently we've typed just 2 input fields name and email in that order, but what if tomo we reearrange it and add more fields? then this line `const [nameInput, emailInput] = screen.getAllByRole("textbox");` would fail the test as it is brittle and hardcoded.
so how do we fix this?
for labels we can provide a htmlFor attr. such that when we tap/click on this label, the input field is active

```html
<label htmlFor="email">enter email</label>
<input type="email" id="email" placeholder="email" />
```

so one way we can target this element can be `screen.getByLabelText(/enter email/i)` or `screen.getByRole('textbox', {name: /enter email/i })`

RTL recommends we use roles, so thats what well be using
the 'i' in the end is basically telling to ignore case sensitivity

so now we have a flexible test, such that if we reorder the components, add more components, this test now, wont fail
and this is the code so far

```jsx
test("should call onUserAdd when the form is submitted", async () => {
  const mock = jest.fn();
  // try to render the component
  render(<UserForm onUserAdd={mock} />);
  // find the 2 inputs
  const nameInput = screen.getByRole("textbox", { name: /name/i });
  const emailInput = screen.getByRole("textbox", { name: /email/i });
  // simulate typing in a name
  await user.click(nameInput);
  await user.keyboard("test name");
  // simulate typing in a email
  await user.click(emailInput);
  await user.keyboard("test@test.com");
  // find the button
  const button = screen.getByRole("button");
  // simulate clicking the button
  await user.click(button);
  // assertion to make sure onUserAdd is called with email and name
  expect(mock).toHaveBeenCalled();
  expect(mock).toHaveBeenCalledWith({
    name: "test name",
    email: "test@test.com",
  });
});
```
